; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: opt -S -linearize-cfg %s | FileCheck %s

define void @no_cipdom_unreachable(i1 %cond0, <4 x float> addrspace(1)* noalias nocapture readonly %arg) {
; CHECK-LABEL: @no_cipdom_unreachable(
; CHECK-NEXT:  bb:
; CHECK-NEXT:    [[TMP:%.*]] = load volatile i32, i32 addrspace(1)* undef
; CHECK-NEXT:    br label [[BB1:%.*]]
; CHECK:       bb1:
; CHECK-NEXT:    [[BB1_LOAD:%.*]] = load volatile i32, i32 addrspace(1)* undef
; CHECK-NEXT:    [[TMP2:%.*]] = sext i32 [[TMP]] to i64
; CHECK-NEXT:    [[TMP3:%.*]] = getelementptr inbounds <4 x float>, <4 x float> addrspace(1)* [[ARG:%.*]], i64 [[TMP2]]
; CHECK-NEXT:    [[TMP4:%.*]] = load <4 x float>, <4 x float> addrspace(1)* [[TMP3]], align 16
; CHECK-NEXT:    br i1 [[COND0:%.*]], label [[BB3:%.*]], label [[BB5_GUARD:%.*]]
; CHECK:       bb3:
; CHECK-NEXT:    [[BB3_LOAD0:%.*]] = load volatile i32, i32 addrspace(1)* undef
; CHECK-NEXT:    [[BB3_LOAD1:%.*]] = load volatile i32, i32 addrspace(1)* undef
; CHECK-NEXT:    [[TMP6:%.*]] = extractelement <4 x float> [[TMP4]], i32 2
; CHECK-NEXT:    [[TMP7:%.*]] = fcmp olt float [[TMP6]], 0.000000e+00
; CHECK-NEXT:    [[BB3_SUCC_ID:%.*]] = select i1 [[TMP7]], i32 3, i32 4
; CHECK-NEXT:    br label [[BB5_GUARD]]
; CHECK:       bb4.guard:
; CHECK-NEXT:    [[GUARD_VAR1:%.*]] = phi i32 [ 5, [[BB5:%.*]] ], [ [[GUARD_VAR:%.*]], [[BB5_GUARD]] ]
; CHECK-NEXT:    [[PREV_GUARD2:%.*]] = icmp eq i32 [[GUARD_VAR1]], 3
; CHECK-NEXT:    br i1 [[PREV_GUARD2]], label [[BB4:%.*]], label [[LINEARIZECFG_UNIFIED_RETURN_GUARD:%.*]]
; CHECK:       bb4:
; CHECK-NEXT:    [[BB4_LOAD:%.*]] = load volatile i32, i32 addrspace(1)* undef
; CHECK-NEXT:    store volatile i32 [[BB3_LOAD03:%.*]], i32 addrspace(1)* undef
; CHECK-NEXT:    br label [[LINEARIZECFG_UNIFIED_RETURN_GUARD]]
; CHECK:       bb5.guard:
; CHECK-NEXT:    [[BB3_LOAD03]] = phi i32 [ undef, [[BB1]] ], [ [[BB3_LOAD0]], [[BB3]] ]
; CHECK-NEXT:    [[GUARD_VAR]] = phi i32 [ 2, [[BB1]] ], [ [[BB3_SUCC_ID]], [[BB3]] ]
; CHECK-NEXT:    [[BB5_PHI_PH:%.*]] = phi i32 [ [[BB1_LOAD]], [[BB1]] ], [ [[BB3_LOAD1]], [[BB3]] ]
; CHECK-NEXT:    [[PREV_GUARD:%.*]] = icmp eq i32 [[GUARD_VAR]], 4
; CHECK-NEXT:    br i1 [[PREV_GUARD]], label [[BB5]], label [[BB4_GUARD:%.*]]
; CHECK:       bb5:
; CHECK-NEXT:    [[BB5_PHI:%.*]] = phi i32 [ [[BB5_PHI_PH]], [[BB5_GUARD]] ]
; CHECK-NEXT:    store volatile i32 [[BB5_PHI]], i32 addrspace(1)* undef
; CHECK-NEXT:    br label [[BB4_GUARD]]
; CHECK:       linearizecfg.unified.return.guard:
; CHECK-NEXT:    br label [[LINEARIZECFG_UNIFIED_RETURN:%.*]]
; CHECK:       linearizecfg.unified.return:
; CHECK-NEXT:    ret void
;
bb:
  %tmp = load volatile i32, i32 addrspace(1)* undef
  br label %bb1

bb1:
  %bb1.load = load volatile i32, i32 addrspace(1)* undef
  %tmp2 = sext i32 %tmp to i64
  %tmp3 = getelementptr inbounds <4 x float>, <4 x float> addrspace(1)* %arg, i64 %tmp2
  %tmp4 = load <4 x float>, <4 x float> addrspace(1)* %tmp3, align 16
  br i1 %cond0, label %bb3, label %bb5

bb3:
  %bb3.load0 = load volatile i32, i32 addrspace(1)* undef
  %bb3.load1 = load volatile i32, i32 addrspace(1)* undef
  %tmp6 = extractelement <4 x float> %tmp4, i32 2
  %tmp7 = fcmp olt float %tmp6, 0.000000e+00
  br i1 %tmp7, label %bb4, label %bb5

bb4:
  %bb4.load = load volatile i32, i32 addrspace(1)* undef
  store volatile i32 %bb3.load0, i32 addrspace(1)* undef
  unreachable

bb5:
  %bb5.phi = phi i32 [ %bb3.load1, %bb3 ], [ %bb1.load, %bb1 ]
  store volatile i32 %bb5.phi, i32 addrspace(1)* undef
  unreachable
}

; Due to a bug in calculating the CIPDOM, this case did not work
; correctly without the single successor branch to bb1.
define i32 @no_cipdom_unreachable_no_extra_branch(i1 %cond0, <4 x float> addrspace(1)* noalias nocapture readonly %arg) {
; CHECK-LABEL: @no_cipdom_unreachable_no_extra_branch(
; CHECK-NEXT:  bb:
; CHECK-NEXT:    [[TMP:%.*]] = load volatile i32, i32 addrspace(1)* undef
; CHECK-NEXT:    [[BB1_LOAD:%.*]] = load volatile i32, i32 addrspace(1)* undef
; CHECK-NEXT:    [[TMP2:%.*]] = sext i32 [[TMP]] to i64
; CHECK-NEXT:    [[TMP3:%.*]] = getelementptr inbounds <4 x float>, <4 x float> addrspace(1)* [[ARG:%.*]], i64 [[TMP2]]
; CHECK-NEXT:    [[TMP4:%.*]] = load <4 x float>, <4 x float> addrspace(1)* [[TMP3]], align 16
; CHECK-NEXT:    br i1 [[COND0:%.*]], label [[BB3:%.*]], label [[BB5_GUARD:%.*]]
; CHECK:       bb3:
; CHECK-NEXT:    [[BB3_LOAD0:%.*]] = load volatile i32, i32 addrspace(1)* undef
; CHECK-NEXT:    [[BB3_LOAD1:%.*]] = load volatile i32, i32 addrspace(1)* undef
; CHECK-NEXT:    [[TMP6:%.*]] = extractelement <4 x float> [[TMP4]], i32 2
; CHECK-NEXT:    [[TMP7:%.*]] = fcmp olt float [[TMP6]], 0.000000e+00
; CHECK-NEXT:    [[BB3_SUCC_ID:%.*]] = select i1 [[TMP7]], i32 2, i32 3
; CHECK-NEXT:    br label [[BB5_GUARD]]
; CHECK:       bb4.guard:
; CHECK-NEXT:    [[BB5_PHI4:%.*]] = phi i32 [ [[BB5_PHI:%.*]], [[BB5:%.*]] ], [ undef, [[BB5_GUARD]] ]
; CHECK-NEXT:    [[GUARD_VAR1:%.*]] = phi i32 [ 4, [[BB5]] ], [ [[GUARD_VAR:%.*]], [[BB5_GUARD]] ]
; CHECK-NEXT:    [[PREV_GUARD2:%.*]] = icmp eq i32 [[GUARD_VAR1]], 2
; CHECK-NEXT:    br i1 [[PREV_GUARD2]], label [[BB4:%.*]], label [[LINEARIZECFG_UNIFIED_RETURN_GUARD:%.*]]
; CHECK:       bb4:
; CHECK-NEXT:    [[BB4_LOAD:%.*]] = load volatile i32, i32 addrspace(1)* undef
; CHECK-NEXT:    store volatile i32 [[BB3_LOAD03:%.*]], i32 addrspace(1)* undef
; CHECK-NEXT:    br label [[LINEARIZECFG_UNIFIED_RETURN_GUARD]]
; CHECK:       bb5.guard:
; CHECK-NEXT:    [[BB3_LOAD03]] = phi i32 [ undef, [[BB:%.*]] ], [ [[BB3_LOAD0]], [[BB3]] ]
; CHECK-NEXT:    [[GUARD_VAR]] = phi i32 [ 1, [[BB]] ], [ [[BB3_SUCC_ID]], [[BB3]] ]
; CHECK-NEXT:    [[BB5_PHI_PH:%.*]] = phi i32 [ [[BB1_LOAD]], [[BB]] ], [ [[BB3_LOAD1]], [[BB3]] ]
; CHECK-NEXT:    [[PREV_GUARD:%.*]] = icmp eq i32 [[GUARD_VAR]], 3
; CHECK-NEXT:    br i1 [[PREV_GUARD]], label [[BB5]], label [[BB4_GUARD:%.*]]
; CHECK:       bb5:
; CHECK-NEXT:    [[BB5_PHI]] = phi i32 [ [[BB5_PHI_PH]], [[BB5_GUARD]] ]
; CHECK-NEXT:    store volatile i32 [[BB5_PHI]], i32 addrspace(1)* undef
; CHECK-NEXT:    br label [[BB4_GUARD]]
; CHECK:       linearizecfg.unified.return.guard:
; CHECK-NEXT:    [[UNIFIEDRETVAL_PH:%.*]] = phi i32 [ [[BB5_PHI4]], [[BB4_GUARD]] ], [ [[BB4_LOAD]], [[BB4]] ]
; CHECK-NEXT:    br label [[LINEARIZECFG_UNIFIED_RETURN:%.*]]
; CHECK:       linearizecfg.unified.return:
; CHECK-NEXT:    [[UNIFIEDRETVAL:%.*]] = phi i32 [ [[UNIFIEDRETVAL_PH]], [[LINEARIZECFG_UNIFIED_RETURN_GUARD]] ]
; CHECK-NEXT:    ret i32 [[UNIFIEDRETVAL]]
;
bb:
  %tmp = load volatile i32, i32 addrspace(1)* undef
  %bb1.load = load volatile i32, i32 addrspace(1)* undef
  %tmp2 = sext i32 %tmp to i64
  %tmp3 = getelementptr inbounds <4 x float>, <4 x float> addrspace(1)* %arg, i64 %tmp2
  %tmp4 = load <4 x float>, <4 x float> addrspace(1)* %tmp3, align 16
  br i1 %cond0, label %bb3, label %bb5

bb3:
  %bb3.load0 = load volatile i32, i32 addrspace(1)* undef
  %bb3.load1 = load volatile i32, i32 addrspace(1)* undef
  %tmp6 = extractelement <4 x float> %tmp4, i32 2
  %tmp7 = fcmp olt float %tmp6, 0.000000e+00
  br i1 %tmp7, label %bb4, label %bb5

bb4:
  %bb4.load = load volatile i32, i32 addrspace(1)* undef
  store volatile i32 %bb3.load0, i32 addrspace(1)* undef
  ret i32 %bb4.load

bb5:
  %bb5.phi = phi i32 [ %bb3.load1, %bb3 ], [ %bb1.load, %bb ]
  store volatile i32 %bb5.phi, i32 addrspace(1)* undef
  ret i32 %bb5.phi
}
