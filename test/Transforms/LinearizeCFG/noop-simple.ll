; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: opt -S -linearize-cfg %s | FileCheck %s

; Simple CFGs the structurizer should not touch. The old structurizer
; would often make changes to already structured CFGs, so that
; rerunning the structurizer would keep increasing the block count.

define void @empty_ret() {
; CHECK-LABEL: @empty_ret(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    ret void
;
entry:
  ret void
}

define void @empty_unreachable() {
; CHECK-LABEL: @empty_unreachable(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    unreachable
;
entry:
  unreachable
}

define void @triangle_if(i1 %cond0) {
; CHECK-LABEL: @triangle_if(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[LOAD_ENTRY:%.*]] = load i32, i32 addrspace(1)* undef
; CHECK-NEXT:    store i32 0, i32 addrspace(1)* undef
; CHECK-NEXT:    br i1 [[COND0:%.*]], label [[IF:%.*]], label [[ENDIF:%.*]]
; CHECK:       if:
; CHECK-NEXT:    [[LOAD_IF:%.*]] = load i32, i32 addrspace(1)* undef
; CHECK-NEXT:    store i32 1, i32 addrspace(1)* undef
; CHECK-NEXT:    br label [[ENDIF]]
; CHECK:       endif:
; CHECK-NEXT:    [[PHI:%.*]] = phi i32 [ [[LOAD_ENTRY]], [[ENTRY:%.*]] ], [ [[LOAD_IF]], [[IF]] ]
; CHECK-NEXT:    store i32 [[PHI]], i32 addrspace(1)* undef
; CHECK-NEXT:    ret void
;
entry:
  %load.entry = load i32, i32 addrspace(1)* undef
  store i32 0, i32 addrspace(1)* undef
  br i1 %cond0, label %if, label %endif

if:
  %load.if = load i32, i32 addrspace(1)* undef
  store i32 1, i32 addrspace(1)* undef
  br label %endif

endif:
  %phi = phi i32 [ %load.entry, %entry ], [ %load.if, %if ]
  store i32 %phi, i32 addrspace(1)* undef
  ret void
}

define void @diamond_if(i1 %cond0) {
; CHECK-LABEL: @diamond_if(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[ENTRY_LOAD:%.*]] = load volatile i32, i32 addrspace(1)* undef
; CHECK-NEXT:    store volatile i32 0, i32 addrspace(1)* undef
; CHECK-NEXT:    br i1 [[COND0:%.*]], label [[IF:%.*]], label [[ELSE:%.*]]
; CHECK:       if:
; CHECK-NEXT:    [[IF_LOAD:%.*]] = load volatile i32, i32 addrspace(1)* undef
; CHECK-NEXT:    store volatile i32 1, i32 addrspace(1)* undef
; CHECK-NEXT:    br label [[ENDIF:%.*]]
; CHECK:       else:
; CHECK-NEXT:    [[ELSE_LOAD:%.*]] = load volatile i32, i32 addrspace(1)* undef
; CHECK-NEXT:    store volatile i32 1, i32 addrspace(1)* undef
; CHECK-NEXT:    br label [[ENDIF]]
; CHECK:       endif:
; CHECK-NEXT:    [[ENDIF_PHI:%.*]] = phi i32 [ [[IF_LOAD]], [[IF]] ], [ [[ELSE_LOAD]], [[ELSE]] ]
; CHECK-NEXT:    store volatile i32 [[ENDIF_PHI]], i32 addrspace(1)* undef
; CHECK-NEXT:    ret void
;
entry:
  %entry.load = load volatile i32, i32 addrspace(1)* undef
  store volatile i32 0, i32 addrspace(1)* undef
  br i1 %cond0, label %if, label %else

if:
  %if.load = load volatile i32, i32 addrspace(1)* undef
  store volatile i32 1, i32 addrspace(1)* undef
  br label %endif

else:
  %else.load = load volatile i32, i32 addrspace(1)* undef
  store volatile i32 1, i32 addrspace(1)* undef
  br label %endif

endif:
  %endif.phi = phi i32 [ %if.load, %if ], [ %else.load, %else ]
  store volatile i32 %endif.phi, i32 addrspace(1)* undef
  ret void
}

define void @for_loop(i32 addrspace(1)* %out, i32 %n) {
; CHECK-LABEL: @for_loop(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[ENTRY_LOAD:%.*]] = load volatile i32, i32 addrspace(1)* undef
; CHECK-NEXT:    br label [[LOOP_HEADER_GUARD:%.*]]
; CHECK:       loop.header.guard:
; CHECK-NEXT:    [[I_INC8:%.*]] = phi i32 [ [[I_INC9:%.*]], [[FOR_BODY_SPLIT:%.*]] ], [ undef, [[ENTRY:%.*]] ]
; CHECK-NEXT:    [[LOOP_HEADER_LOAD6:%.*]] = phi i32 [ [[LOOP_HEADER_LOAD7:%.*]], [[FOR_BODY_SPLIT]] ], [ undef, [[ENTRY]] ]
; CHECK-NEXT:    [[I_03:%.*]] = phi i32 [ [[I_04:%.*]], [[FOR_BODY_SPLIT]] ], [ undef, [[ENTRY]] ]
; CHECK-NEXT:    [[GUARD_VAR:%.*]] = phi i32 [ 2, [[FOR_BODY_SPLIT]] ], [ 1, [[ENTRY]] ]
; CHECK-NEXT:    [[I_0_PH:%.*]] = phi i32 [ [[I_INC9]], [[FOR_BODY_SPLIT]] ], [ 0, [[ENTRY]] ]
; CHECK-NEXT:    [[PREV_GUARD:%.*]] = icmp eq i32 [[GUARD_VAR]], 1
; CHECK-NEXT:    br i1 [[PREV_GUARD]], label [[LOOP_HEADER:%.*]], label [[FOR_BODY_GUARD:%.*]]
; CHECK:       loop.header:
; CHECK-NEXT:    [[I_0:%.*]] = phi i32 [ [[I_0_PH]], [[LOOP_HEADER_GUARD]] ]
; CHECK-NEXT:    [[LOOP_HEADER_LOAD:%.*]] = load volatile i32, i32 addrspace(1)* undef
; CHECK-NEXT:    [[CMP:%.*]] = icmp ugt i32 [[I_0]], [[N:%.*]]
; CHECK-NEXT:    [[TMP0:%.*]] = select i1 [[CMP]], i32 2, i32 3
; CHECK-NEXT:    br i1 [[CMP]], label [[FOR_BODY_GUARD]], label [[FOR_END:%.*]]
; CHECK:       for.body.guard:
; CHECK-NEXT:    [[LOOP_HEADER_LOAD7]] = phi i32 [ [[LOOP_HEADER_LOAD6]], [[LOOP_HEADER_GUARD]] ], [ [[LOOP_HEADER_LOAD]], [[LOOP_HEADER]] ]
; CHECK-NEXT:    [[I_04]] = phi i32 [ [[I_03]], [[LOOP_HEADER_GUARD]] ], [ [[I_0]], [[LOOP_HEADER]] ]
; CHECK-NEXT:    [[GUARD_VAR1:%.*]] = phi i32 [ [[GUARD_VAR]], [[LOOP_HEADER_GUARD]] ], [ [[TMP0]], [[LOOP_HEADER]] ]
; CHECK-NEXT:    [[LAST:%.*]] = icmp eq i32 [[GUARD_VAR1]], 2
; CHECK-NEXT:    br i1 [[LAST]], label [[FOR_BODY:%.*]], label [[FOR_END]]
; CHECK:       for.body:
; CHECK-NEXT:    [[BE_GUARD:%.*]] = icmp eq i32 [[GUARD_VAR1]], 2
; CHECK-NEXT:    br i1 [[BE_GUARD]], label [[FOR_BODY_SPLIT2:%.*]], label [[FOR_BODY_SPLIT]]
; CHECK:       for.body.split2:
; CHECK-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds i32, i32 addrspace(1)* [[OUT:%.*]], i32 [[I_04]]
; CHECK-NEXT:    store i32 [[I_04]], i32 addrspace(1)* [[ARRAYIDX]], align 4
; CHECK-NEXT:    [[I_INC:%.*]] = add i32 [[I_04]], 1
; CHECK-NEXT:    [[ARRAYIDX3:%.*]] = getelementptr inbounds i32, i32 addrspace(1)* [[OUT]], i32 [[I_INC]]
; CHECK-NEXT:    store i32 [[I_04]], i32 addrspace(1)* [[ARRAYIDX3]], align 4
; CHECK-NEXT:    br label [[FOR_BODY_SPLIT]]
; CHECK:       for.body.split:
; CHECK-NEXT:    [[I_INC9]] = phi i32 [ [[I_INC8]], [[FOR_BODY]] ], [ [[I_INC]], [[FOR_BODY_SPLIT2]] ]
; CHECK-NEXT:    br label [[LOOP_HEADER_GUARD]]
; CHECK:       for.end:
; CHECK-NEXT:    [[LOOP_HEADER_LOAD5:%.*]] = phi i32 [ [[LOOP_HEADER_LOAD7]], [[FOR_BODY_GUARD]] ], [ [[LOOP_HEADER_LOAD]], [[LOOP_HEADER]] ]
; CHECK-NEXT:    store volatile i32 [[LOOP_HEADER_LOAD5]], i32 addrspace(1)* undef
; CHECK-NEXT:    ret void
;
entry:
  %entry.load = load volatile i32, i32 addrspace(1)* undef
  br label %loop.header

loop.header:
  %i.0 = phi i32 [ 0, %entry ], [ %i.inc, %for.body ]
  %loop.header.load = load volatile i32, i32 addrspace(1)* undef
  %cmp = icmp ugt i32 %i.0, %n
  br i1 %cmp, label %for.body, label %for.end

for.body:
  %arrayidx = getelementptr inbounds i32, i32 addrspace(1)* %out, i32 %i.0
  store i32 %i.0, i32 addrspace(1)* %arrayidx, align 4
  %i.inc = add i32 %i.0, 1
  %arrayidx3 = getelementptr inbounds i32, i32 addrspace(1)* %out, i32 %i.inc
  store i32 %i.0, i32 addrspace(1)* %arrayidx3, align 4
  br label %loop.header

for.end:
  store volatile i32 %loop.header.load, i32 addrspace(1)* undef
  ret void
}

define void @do_while_loop(i32 addrspace(1)* %out, i32 %n) {
; CHECK-LABEL: @do_while_loop(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[ENTRY_LOAD:%.*]] = load volatile i32, i32 addrspace(1)* undef
; CHECK-NEXT:    br label [[DO_BODY:%.*]]
; CHECK:       do.body:
; CHECK-NEXT:    [[I_0:%.*]] = phi i32 [ 0, [[ENTRY:%.*]] ], [ [[I_INC:%.*]], [[DO_BODY]] ]
; CHECK-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds i32, i32 addrspace(1)* [[OUT:%.*]], i32 [[I_0]]
; CHECK-NEXT:    store i32 [[I_0]], i32 addrspace(1)* [[ARRAYIDX]], align 4
; CHECK-NEXT:    [[CMP:%.*]] = icmp ugt i32 [[I_0]], [[N:%.*]]
; CHECK-NEXT:    [[I_INC]] = add i32 [[I_0]], 1
; CHECK-NEXT:    [[ARRAYIDX3:%.*]] = getelementptr inbounds i32, i32 addrspace(1)* [[OUT]], i32 [[I_INC]]
; CHECK-NEXT:    [[DO_BODY_LOAD:%.*]] = load volatile i32, i32 addrspace(1)* [[ARRAYIDX3]]
; CHECK-NEXT:    store i32 [[I_0]], i32 addrspace(1)* [[ARRAYIDX3]], align 4
; CHECK-NEXT:    br i1 [[CMP]], label [[DO_BODY]], label [[DO_END:%.*]]
; CHECK:       do.end:
; CHECK-NEXT:    store volatile i32 [[DO_BODY_LOAD]], i32 addrspace(1)* undef
; CHECK-NEXT:    ret void
;
entry:
  %entry.load = load volatile i32, i32 addrspace(1)* undef
  br label %do.body

do.body:
  %i.0 = phi i32 [ 0, %entry ], [ %i.inc, %do.body ]
  %arrayidx = getelementptr inbounds i32, i32 addrspace(1)* %out, i32 %i.0
  store i32 %i.0, i32 addrspace(1)* %arrayidx, align 4
  %cmp = icmp ugt i32 %i.0, %n
  %i.inc = add i32 %i.0, 1
  %arrayidx3 = getelementptr inbounds i32, i32 addrspace(1)* %out, i32 %i.inc
  %do.body.load = load volatile i32, i32 addrspace(1)* %arrayidx3
  store i32 %i.0, i32 addrspace(1)* %arrayidx3, align 4
  br i1 %cmp, label %do.body, label %do.end

do.end:
  store volatile i32 %do.body.load, i32 addrspace(1)* undef
  ret void
}

define void @infinite_loop() {
; CHECK-LABEL: @infinite_loop(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[ENTRY_LOAD:%.*]] = load volatile i32, i32 addrspace(1)* undef
; CHECK-NEXT:    br label [[LOOP:%.*]]
; CHECK:       loop:
; CHECK-NEXT:    [[PHI:%.*]] = phi i32 [ [[ENTRY_LOAD]], [[ENTRY:%.*]] ], [ [[LOOP_LOAD:%.*]], [[LOOP]] ]
; CHECK-NEXT:    [[LOOP_LOAD]] = load volatile i32, i32 addrspace(1)* undef
; CHECK-NEXT:    store volatile i32 1, i32 addrspace(1)* undef
; CHECK-NEXT:    br label [[LOOP]]
;
entry:
  %entry.load = load volatile i32, i32 addrspace(1)* undef
  br label %loop

loop:
  %phi = phi i32 [ %entry.load, %entry ], [ %loop.load, %loop ]
  %loop.load = load volatile i32, i32 addrspace(1)* undef
  store volatile i32 1, i32 addrspace(1)* undef
  br label %loop
}
