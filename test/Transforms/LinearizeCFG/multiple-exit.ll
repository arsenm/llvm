; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: opt -S -linearize-cfg -linearize-whole-function %s | FileCheck %s

; TODO: Merge with CodeGen/AMDGPU/multi-divergent-exit-region.ll

define void @unreachable_ret(i1 %cond0) {
; CHECK-LABEL: @unreachable_ret(
; CHECK-NEXT:  dummy.idom:
; CHECK-NEXT:    br label [[ENTRY_GUARD:%.*]]
; CHECK:       entry.guard:
; CHECK-NEXT:    br label [[ENTRY:%.*]]
; CHECK:       entry:
; CHECK-NEXT:    [[ENTRY_LOAD:%.*]] = load volatile i32, i32 addrspace(1)* undef
; CHECK-NEXT:    [[TMP0:%.*]] = select i1 [[COND0:%.*]], i32 1, i32 2
; CHECK-NEXT:    br label [[RET_GUARD:%.*]]
; CHECK:       bb.unreach.guard:
; CHECK-NEXT:    [[LAST:%.*]] = icmp eq i32 [[TMP0]], 1
; CHECK-NEXT:    br i1 [[LAST]], label [[BB_UNREACH:%.*]], label [[BB_UNREACH_SPLIT:%.*]]
; CHECK:       bb.unreach:
; CHECK-NEXT:    store volatile i32 [[ENTRY_LOAD]], i32 addrspace(1)* undef
; CHECK-NEXT:    br label [[BB_UNREACH_SPLIT]]
; CHECK:       bb.unreach.split:
; CHECK-NEXT:    unreachable
; CHECK:       ret.guard:
; CHECK-NEXT:    [[PREV_GUARD:%.*]] = icmp eq i32 [[TMP0]], 2
; CHECK-NEXT:    br i1 [[PREV_GUARD]], label [[RET:%.*]], label [[BB_UNREACH_GUARD:%.*]]
; CHECK:       ret:
; CHECK-NEXT:    store volatile i32 1, i32 addrspace(1)* undef
; CHECK-NEXT:    ret void
;
entry:
  %entry.load = load volatile i32, i32 addrspace(1)* undef
  br i1 %cond0, label %bb.unreach, label %ret

bb.unreach:
  store volatile i32 %entry.load, i32 addrspace(1)* undef
  unreachable

ret:
  store volatile i32 1, i32 addrspace(1)* undef
  ret void
}

define void @unreachable_unreachable(i1 %cond0) {
; CHECK-LABEL: @unreachable_unreachable(
; CHECK-NEXT:  dummy.idom:
; CHECK-NEXT:    br label [[ENTRY_GUARD:%.*]]
; CHECK:       entry.guard:
; CHECK-NEXT:    br label [[ENTRY:%.*]]
; CHECK:       entry:
; CHECK-NEXT:    [[ENTRY_LOAD:%.*]] = load volatile i32, i32 addrspace(1)* undef
; CHECK-NEXT:    [[TMP0:%.*]] = select i1 [[COND0:%.*]], i32 1, i32 2
; CHECK-NEXT:    br label [[UNREACH1_BB_GUARD:%.*]]
; CHECK:       unreach0.bb.guard:
; CHECK-NEXT:    [[LAST:%.*]] = icmp eq i32 [[TMP0]], 1
; CHECK-NEXT:    br i1 [[LAST]], label [[UNREACH0_BB:%.*]], label [[UNREACH0_BB_SPLIT:%.*]]
; CHECK:       unreach0.bb:
; CHECK-NEXT:    store volatile i32 [[ENTRY_LOAD]], i32 addrspace(1)* undef
; CHECK-NEXT:    br label [[UNREACH0_BB_SPLIT]]
; CHECK:       unreach0.bb.split:
; CHECK-NEXT:    unreachable
; CHECK:       unreach1.bb.guard:
; CHECK-NEXT:    [[PREV_GUARD:%.*]] = icmp eq i32 [[TMP0]], 2
; CHECK-NEXT:    br i1 [[PREV_GUARD]], label [[UNREACH1_BB:%.*]], label [[UNREACH0_BB_GUARD:%.*]]
; CHECK:       unreach1.bb:
; CHECK-NEXT:    store volatile i32 1, i32 addrspace(1)* undef
; CHECK-NEXT:    unreachable
;
entry:
  %entry.load = load volatile i32, i32 addrspace(1)* undef
  br i1 %cond0, label %unreach0.bb, label %unreach1.bb

unreach0.bb:
  store volatile i32 %entry.load, i32 addrspace(1)* undef
  unreachable

unreach1.bb:
  store volatile i32 1, i32 addrspace(1)* undef
  unreachable
}

define void @ret_ret(i1 %cond0) {
; CHECK-LABEL: @ret_ret(
; CHECK-NEXT:  dummy.idom:
; CHECK-NEXT:    br label [[ENTRY_GUARD:%.*]]
; CHECK:       entry.guard:
; CHECK-NEXT:    br label [[ENTRY:%.*]]
; CHECK:       entry:
; CHECK-NEXT:    [[ENTRY_LOAD:%.*]] = load i32, i32 addrspace(1)* undef
; CHECK-NEXT:    [[TMP0:%.*]] = select i1 [[COND0:%.*]], i32 1, i32 2
; CHECK-NEXT:    br label [[RET1_GUARD:%.*]]
; CHECK:       ret0.guard:
; CHECK-NEXT:    [[LAST:%.*]] = icmp eq i32 [[TMP0]], 1
; CHECK-NEXT:    br i1 [[LAST]], label [[RET0:%.*]], label [[RET0_SPLIT:%.*]]
; CHECK:       ret0:
; CHECK-NEXT:    store volatile i32 [[ENTRY_LOAD]], i32 addrspace(1)* undef
; CHECK-NEXT:    br label [[RET0_SPLIT]]
; CHECK:       ret0.split:
; CHECK-NEXT:    ret void
; CHECK:       ret1.guard:
; CHECK-NEXT:    [[PREV_GUARD:%.*]] = icmp eq i32 [[TMP0]], 2
; CHECK-NEXT:    br i1 [[PREV_GUARD]], label [[RET1:%.*]], label [[RET0_GUARD:%.*]]
; CHECK:       ret1:
; CHECK-NEXT:    store volatile i32 1, i32 addrspace(1)* undef
; CHECK-NEXT:    ret void
;
entry:
  %entry.load = load i32, i32 addrspace(1)* undef
  br i1 %cond0, label %ret0, label %ret1

ret0:
  store volatile i32 %entry.load, i32 addrspace(1)* undef
  ret void

ret1:
  store volatile i32 1, i32 addrspace(1)* undef
  ret void
}
