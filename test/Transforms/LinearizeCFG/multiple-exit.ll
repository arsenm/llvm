; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: opt -S -linearize-cfg -linearize-whole-function %s | FileCheck %s

; TODO: Merge with CodeGen/AMDGPU/multi-divergent-exit-region.ll

define void @unreachable_ret(i1 %cond0) {
; CHECK-LABEL: @unreachable_ret(
; CHECK-NEXT:  dummy.idom:
; CHECK-NEXT:    br label [[ENTRY_GUARD:%.*]]
; CHECK:       entry.guard:
; CHECK-NEXT:    br label [[ENTRY:%.*]]
; CHECK:       entry:
; CHECK-NEXT:    [[ENTRY_LOAD:%.*]] = load volatile i32, i32 addrspace(1)* undef
; CHECK-NEXT:    [[TMP0:%.*]] = select i1 [[COND0:%.*]], i32 1, i32 2
; CHECK-NEXT:    br label [[RET_GUARD:%.*]]
; CHECK:       bb.unreach.guard:
; CHECK-NEXT:    [[LAST:%.*]] = icmp eq i32 [[TMP0]], 1
; CHECK-NEXT:    br i1 [[LAST]], label [[BB_UNREACH:%.*]], label [[BB_UNREACH_SPLIT:%.*]]
; CHECK:       bb.unreach:
; CHECK-NEXT:    store volatile i32 [[ENTRY_LOAD]], i32 addrspace(1)* undef
; CHECK-NEXT:    br label [[BB_UNREACH_SPLIT]]
; CHECK:       bb.unreach.split:
; CHECK-NEXT:    unreachable
; CHECK:       ret.guard:
; CHECK-NEXT:    [[PREV_GUARD:%.*]] = icmp eq i32 [[TMP0]], 2
; CHECK-NEXT:    br i1 [[PREV_GUARD]], label [[RET:%.*]], label [[BB_UNREACH_GUARD:%.*]]
; CHECK:       ret:
; CHECK-NEXT:    store volatile i32 1, i32 addrspace(1)* undef
; CHECK-NEXT:    ret void
;
entry:
  %entry.load = load volatile i32, i32 addrspace(1)* undef
  br i1 %cond0, label %bb.unreach, label %ret

bb.unreach:
  store volatile i32 %entry.load, i32 addrspace(1)* undef
  unreachable

ret:
  store volatile i32 1, i32 addrspace(1)* undef
  ret void
}

define i32 @unreachable_ret_nonvoid(i1 %cond0) {
entry:
  %entry.load = load volatile i32, i32 addrspace(1)* undef
  br i1 %cond0, label %bb.unreach, label %ret

bb.unreach:
  store volatile i32 %entry.load, i32 addrspace(1)* undef
  unreachable

ret:
  store volatile i32 1, i32 addrspace(1)* undef
  %ret.load = load volatile i32, i32 addrspace(1)* undef
  ret i32 %ret.load
}

define void @unreachable_unreachable(i1 %cond0) {
; CHECK-LABEL: @unreachable_unreachable(
; CHECK-NEXT:  dummy.idom:
; CHECK-NEXT:    br label [[ENTRY_GUARD:%.*]]
; CHECK:       entry.guard:
; CHECK-NEXT:    br label [[ENTRY:%.*]]
; CHECK:       entry:
; CHECK-NEXT:    [[ENTRY_LOAD:%.*]] = load volatile i32, i32 addrspace(1)* undef
; CHECK-NEXT:    [[TMP0:%.*]] = select i1 [[COND0:%.*]], i32 1, i32 2
; CHECK-NEXT:    br label [[UNREACH1_BB_GUARD:%.*]]
; CHECK:       unreach0.bb.guard:
; CHECK-NEXT:    [[LAST:%.*]] = icmp eq i32 [[TMP0]], 1
; CHECK-NEXT:    br i1 [[LAST]], label [[UNREACH0_BB:%.*]], label [[UNREACH0_BB_SPLIT:%.*]]
; CHECK:       unreach0.bb:
; CHECK-NEXT:    store volatile i32 [[ENTRY_LOAD]], i32 addrspace(1)* undef
; CHECK-NEXT:    br label [[UNREACH0_BB_SPLIT]]
; CHECK:       unreach0.bb.split:
; CHECK-NEXT:    unreachable
; CHECK:       unreach1.bb.guard:
; CHECK-NEXT:    [[PREV_GUARD:%.*]] = icmp eq i32 [[TMP0]], 2
; CHECK-NEXT:    br i1 [[PREV_GUARD]], label [[UNREACH1_BB:%.*]], label [[UNREACH0_BB_GUARD:%.*]]
; CHECK:       unreach1.bb:
; CHECK-NEXT:    store volatile i32 1, i32 addrspace(1)* undef
; CHECK-NEXT:    unreachable
;
entry:
  %entry.load = load volatile i32, i32 addrspace(1)* undef
  br i1 %cond0, label %unreach0.bb, label %unreach1.bb

unreach0.bb:
  store volatile i32 %entry.load, i32 addrspace(1)* undef
  unreachable

unreach1.bb:
  store volatile i32 1, i32 addrspace(1)* undef
  unreachable
}

define void @ret_ret(i1 %cond0) {
; CHECK-LABEL: @ret_ret(
; CHECK-NEXT:  dummy.idom:
; CHECK-NEXT:    br label [[ENTRY_GUARD:%.*]]
; CHECK:       entry.guard:
; CHECK-NEXT:    br label [[ENTRY:%.*]]
; CHECK:       entry:
; CHECK-NEXT:    [[ENTRY_LOAD:%.*]] = load i32, i32 addrspace(1)* undef
; CHECK-NEXT:    [[TMP0:%.*]] = select i1 [[COND0:%.*]], i32 1, i32 2
; CHECK-NEXT:    br label [[RET1_GUARD:%.*]]
; CHECK:       ret0.guard:
; CHECK-NEXT:    [[LAST:%.*]] = icmp eq i32 [[TMP0]], 1
; CHECK-NEXT:    br i1 [[LAST]], label [[RET0:%.*]], label [[RET0_SPLIT:%.*]]
; CHECK:       ret0:
; CHECK-NEXT:    store volatile i32 [[ENTRY_LOAD]], i32 addrspace(1)* undef
; CHECK-NEXT:    br label [[RET0_SPLIT]]
; CHECK:       ret0.split:
; CHECK-NEXT:    ret void
; CHECK:       ret1.guard:
; CHECK-NEXT:    [[PREV_GUARD:%.*]] = icmp eq i32 [[TMP0]], 2
; CHECK-NEXT:    br i1 [[PREV_GUARD]], label [[RET1:%.*]], label [[RET0_GUARD:%.*]]
; CHECK:       ret1:
; CHECK-NEXT:    store volatile i32 1, i32 addrspace(1)* undef
; CHECK-NEXT:    ret void
;
entry:
  %entry.load = load i32, i32 addrspace(1)* undef
  br i1 %cond0, label %ret0, label %ret1

ret0:
  store volatile i32 %entry.load, i32 addrspace(1)* undef
  ret void

ret1:
  store volatile i32 1, i32 addrspace(1)* undef
  ret void
}

define void @infloop_infloop(i1 %cond0) {
entry:
  %entry.load = load i32, i32 addrspace(1)* undef
  br i1 %cond0, label %loop0, label %loop1

loop0:
  store volatile i32 %entry.load, i32 addrspace(1)* undef
  br label %loop0

loop1:
  store volatile i32 1, i32 addrspace(1)* undef
  br label %loop1
}

define void @infloop_infloop_condbr(i1 %cond0) {
entry:
  %entry.load = load i32, i32 addrspace(1)* undef
  br i1 %cond0, label %loop0, label %loop1

loop0:
  store volatile i32 %entry.load, i32 addrspace(1)* undef
  br i1 true, label %loop0, label %loop0

loop1:
  store volatile i32 1, i32 addrspace(1)* undef
  br i1 true, label %loop1, label %loop1
}

define void @infloop_infloop_varcond(i1 %cond0) {
entry:
  %entry.load = load i32, i32 addrspace(1)* undef
  br i1 %cond0, label %loop0, label %loop1

loop0:
  store volatile i32 %entry.load, i32 addrspace(1)* undef
  %cond1 = load volatile i1, i1 addrspace(1)* undef
  br i1 %cond1, label %loop0, label %loop0

loop1:
  store volatile i32 1, i32 addrspace(1)* undef
  %cond2 = load volatile i1, i1 addrspace(1)* undef
  br i1 %cond2, label %loop1, label %loop1
}

define void @infloop_infloop_varcond_nonself() {
entry:
  %entry.load = load i32, i32 addrspace(1)* undef
  br label %loop.preheader

loop.preheader:
  %cond0 = load volatile i1, i1 addrspace(1)* undef
  br i1 %cond0, label %loop0, label %loop1

loop0:
  store volatile i32 %entry.load, i32 addrspace(1)* undef
  %cond1 = load volatile i1, i1 addrspace(1)* undef
  br label %loop.preheader

loop1:
  store volatile i32 1, i32 addrspace(1)* undef
  %cond2 = load volatile i1, i1 addrspace(1)* undef
  br label %loop.preheader
}

define void @cipdom_crash_infloop_unreachable(i1 %arg, i1 %arg1) {
bb:
  br label %bb2

bb2:
  br i1 %arg, label %bb5, label %bb3

bb3:
  br i1 %arg1, label %bb5, label %bb4

bb4:
  br label %bb4

bb5:
  unreachable
}
