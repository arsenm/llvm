; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: opt -S -linearize-cfg -linearize-whole-function %s | FileCheck %s

define void @switch_phi_error(i1 %cond0, i1 %cond1) {
; CHECK-LABEL: @switch_phi_error(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    store volatile i32 0, i32 addrspace(1)* undef
; CHECK-NEXT:    [[ENTRY_SUCC_ID:%.*]] = select i1 [[COND0:%.*]], i32 2, i32 1
; CHECK-NEXT:    br label [[BB1_GUARD:%.*]]
; CHECK:       bb1.guard:
; CHECK-NEXT:    [[PREV_GUARD:%.*]] = icmp eq i32 [[ENTRY_SUCC_ID]], 1
; CHECK-NEXT:    br i1 [[PREV_GUARD]], label [[BB1:%.*]], label [[BB2_GUARD:%.*]]
; CHECK:       bb1:
; CHECK-NEXT:    [[BB1_LOAD:%.*]] = load volatile i32, i32 addrspace(1)* null
; CHECK-NEXT:    br label [[BB2_GUARD]]
; CHECK:       bb2.guard:
; CHECK-NEXT:    [[GUARD_VAR:%.*]] = phi i32 [ 4, [[BB1]] ], [ [[ENTRY_SUCC_ID]], [[BB1_GUARD]] ]
; CHECK-NEXT:    [[PREV_GUARD1:%.*]] = icmp eq i32 [[GUARD_VAR]], 2
; CHECK-NEXT:    br i1 [[PREV_GUARD1]], label [[BB2:%.*]], label [[BB3_GUARD:%.*]]
; CHECK:       bb2:
; CHECK-NEXT:    [[BB2_LOAD:%.*]] = load volatile i32, i32 addrspace(1)* null
; CHECK-NEXT:    [[BB2_SUCC_ID:%.*]] = select i1 [[COND1:%.*]], i32 4, i32 3
; CHECK-NEXT:    br label [[BB3_GUARD]]
; CHECK:       bb3.guard:
; CHECK-NEXT:    [[BB4_PHI_PH4:%.*]] = phi i32 [ undef, [[BB2_GUARD]] ], [ [[BB2_LOAD]], [[BB2]] ]
; CHECK-NEXT:    [[GUARD_VAR2:%.*]] = phi i32 [ [[GUARD_VAR]], [[BB2_GUARD]] ], [ [[BB2_SUCC_ID]], [[BB2]] ]
; CHECK-NEXT:    [[PREV_GUARD3:%.*]] = icmp eq i32 [[GUARD_VAR2]], 3
; CHECK-NEXT:    br i1 [[PREV_GUARD3]], label [[BB3:%.*]], label [[BB4_GUARD:%.*]]
; CHECK:       bb3:
; CHECK-NEXT:    [[BB3_LOAD:%.*]] = load volatile i32, i32 addrspace(1)* null
; CHECK-NEXT:    br label [[BB4_GUARD]]
; CHECK:       bb4.guard:
; CHECK-NEXT:    [[BB4_PHI_PH:%.*]] = phi i32 [ [[BB3_LOAD]], [[BB3]] ], [ [[BB4_PHI_PH4]], [[BB3_GUARD]] ]
; CHECK-NEXT:    br label [[BB4:%.*]]
; CHECK:       bb4:
; CHECK-NEXT:    [[BB4_PHI:%.*]] = phi i32 [ [[BB4_PHI_PH]], [[BB4_GUARD]] ]
; CHECK-NEXT:    store volatile i32 [[BB4_PHI]], i32 addrspace(1)* null
; CHECK-NEXT:    ret void
;
entry:
  store volatile i32 0, i32 addrspace(1)* undef
  br i1 %cond0, label %bb2, label %bb1

bb1:
  %bb1.load = load volatile i32, i32 addrspace(1)* null
  br label %bb4

bb2:
  %bb2.load = load volatile i32, i32 addrspace(1)* null
  br i1 %cond1, label %bb4, label %bb3

bb3:
  %bb3.load = load volatile i32, i32 addrspace(1)* null
  br label %bb4

bb4:
  %bb4.phi = phi i32 [ %bb1.load, %bb1 ], [ %bb2.load, %bb2 ], [ %bb3.load, %bb3 ]
  store volatile i32 %bb4.phi, i32 addrspace(1)* null
  ret void
}

define void @switch_phi_error_multiexit(i1 %cond0, i1 %cond1) {
; CHECK-LABEL: @switch_phi_error_multiexit(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    store volatile i32 0, i32 addrspace(1)* undef
; CHECK-NEXT:    [[ENTRY_SUCC_ID:%.*]] = select i1 [[COND0:%.*]], i32 2, i32 1
; CHECK-NEXT:    br label [[BB1_GUARD:%.*]]
; CHECK:       bb1.guard:
; CHECK-NEXT:    [[PREV_GUARD:%.*]] = icmp eq i32 [[ENTRY_SUCC_ID]], 1
; CHECK-NEXT:    br i1 [[PREV_GUARD]], label [[BB1:%.*]], label [[BB2_GUARD:%.*]]
; CHECK:       bb1:
; CHECK-NEXT:    [[BB1_LOAD:%.*]] = load volatile i32, i32 addrspace(1)* null
; CHECK-NEXT:    br label [[BB2_GUARD]]
; CHECK:       bb2.guard:
; CHECK-NEXT:    [[GUARD_VAR:%.*]] = phi i32 [ 4, [[BB1]] ], [ [[ENTRY_SUCC_ID]], [[BB1_GUARD]] ]
; CHECK-NEXT:    [[PREV_GUARD1:%.*]] = icmp eq i32 [[GUARD_VAR]], 2
; CHECK-NEXT:    br i1 [[PREV_GUARD1]], label [[BB2:%.*]], label [[BB3_GUARD:%.*]]
; CHECK:       bb2:
; CHECK-NEXT:    [[BB2_LOAD:%.*]] = load volatile i32, i32 addrspace(1)* null
; CHECK-NEXT:    [[BB2_SUCC_ID:%.*]] = select i1 [[COND1:%.*]], i32 4, i32 3
; CHECK-NEXT:    br label [[BB3_GUARD]]
; CHECK:       bb3.guard:
; CHECK-NEXT:    [[BB2_LOAD6:%.*]] = phi i32 [ undef, [[BB2_GUARD]] ], [ [[BB2_LOAD]], [[BB2]] ]
; CHECK-NEXT:    [[GUARD_VAR2:%.*]] = phi i32 [ [[GUARD_VAR]], [[BB2_GUARD]] ], [ [[BB2_SUCC_ID]], [[BB2]] ]
; CHECK-NEXT:    [[PREV_GUARD3:%.*]] = icmp eq i32 [[GUARD_VAR2]], 3
; CHECK-NEXT:    br i1 [[PREV_GUARD3]], label [[BB3:%.*]], label [[BB4_GUARD:%.*]]
; CHECK:       bb3:
; CHECK-NEXT:    store volatile i32 3, i32 addrspace(1)* undef
; CHECK-NEXT:    br label [[BB4_GUARD]]
; CHECK:       bb4.guard:
; CHECK-NEXT:    [[GUARD_VAR4:%.*]] = phi i32 [ 5, [[BB3]] ], [ [[GUARD_VAR2]], [[BB3_GUARD]] ]
; CHECK-NEXT:    [[PREV_GUARD5:%.*]] = icmp eq i32 [[GUARD_VAR4]], 4
; CHECK-NEXT:    br i1 [[PREV_GUARD5]], label [[BB4:%.*]], label [[LINEARIZECFG_UNIFIED_RETURN_GUARD:%.*]]
; CHECK:       bb4:
; CHECK-NEXT:    [[BB4_PHI:%.*]] = phi i32 [ [[BB2_LOAD6]], [[BB4_GUARD]] ]
; CHECK-NEXT:    store volatile i32 [[BB4_PHI]], i32 addrspace(1)* null
; CHECK-NEXT:    br label [[LINEARIZECFG_UNIFIED_RETURN_GUARD]]
; CHECK:       linearizecfg.unified.return.guard:
; CHECK-NEXT:    br label [[LINEARIZECFG_UNIFIED_RETURN:%.*]]
; CHECK:       linearizecfg.unified.return:
; CHECK-NEXT:    ret void
;
entry:
  store volatile i32 0, i32 addrspace(1)* undef
  br i1 %cond0, label %bb2, label %bb1

bb1:
  %bb1.load = load volatile i32, i32 addrspace(1)* null
  br label %bb4

bb2:
  %bb2.load = load volatile i32, i32 addrspace(1)* null
  br i1 %cond1, label %bb4, label %bb3

bb3:
  store volatile i32 3, i32 addrspace(1)* undef
  unreachable

bb4:
  %bb4.phi = phi i32 [ %bb1.load, %bb1 ], [ %bb2.load, %bb2 ]
  store volatile i32 %bb4.phi, i32 addrspace(1)* null
  ret void
}


; define void @switch_phi_error_2(i1 %cond0, i1 %cond1) {
; entry:
;   br i1 %cond0, label %bb2, label %bb1

; bb1:
;   %bb1.load = load volatile i32, i32 addrspace(1)* null
;   br label %bb4

; bb2:
;   %bb2.load = load volatile i32, i32 addrspace(1)* null
;   br i1 %cond1, label %bb4, label %bb3

; bb3:
;   br label %bb4

; bb4:
;   %bb4.phi = phi i32 [ %bb1.load, %bb1 ], [ %bb2.load, %bb2 ], [ undef, %bb3 ]
;   store volatile i32 %bb4.phi, i32 addrspace(1)* null
;   ret void
; }
